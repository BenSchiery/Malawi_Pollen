# interpolate by a cubic spline
char.spline.pred <- spline(x = char.trunc, xout = pollenData$age)[[2]]
# index of the smallest charcoal age greater than the greatest pollen age
last.age.char <- min(which(charcoalData$age > max(pollenData$age)))
# truncate the charcoal data to just what is needed
char.trunc <- charcoalData[1:last.age.char,]
# interpolate linearly
char.linterp.pred <- linterp(x = char.trunc$age,
y = char.trunc$charcoal,
x.out = pollenData$age)
plot(char.trunc, type = "l", lwd = 2, main = "Charcoal Linear Interpolation")
lines(char.linterp.pred ~ pollenData$age, lwd = 1, col = "red")
pollenData <- pollenData[pollenData$age > 80 & pollenData$age < 100,]
tail(pollenData)
tail(lakeData)
tail(charcoalData)
# index of the smallest charcoal age greater than the greatest pollen age
last.age.char <- min(which(charcoalData$age > max(pollenData$age)))
# truncate the charcoal data to just what is needed
char.trunc <- charcoalData[1:last.age.char,]
# interpolate linearly
char.linterp.pred <- linterp(x = char.trunc$age,
y = char.trunc$charcoal,
x.out = pollenData$age)
plot(char.trunc, type = "l", lwd = 2, main = "Charcoal Linear Interpolation")
lines(char.linterp.pred ~ pollenData$age, lwd = 1, col = "red")
# index of the greatest charcoal age lass than the least pollen age
first.age.char <- max(which(charcharcoalData$age < min(pollenData$age)))
# index of the greatest charcoal age lass than the least pollen age
first.age.char <- max(which(charcoalData$age < min(pollenData$age)))
first.age.char
# truncate the charcoal data to just what is needed
char.trunc <- charcoalData[first.age.char:last.age.char,]
# interpolate linearly
char.linterp.pred <- linterp(x = char.trunc$age,
y = char.trunc$charcoal,
x.out = pollenData$age)
plot(char.trunc, type = "l", lwd = 2, main = "Charcoal Linear Interpolation")
lines(char.linterp.pred ~ pollenData$age, lwd = 1, col = "red")
points(0 ~ pollenData$age)
points(1 ~ pollenData$age)
points((pollenData$age - pollenData$age) ~ pollenData$age)
# make sure data are in chronological order
pollenData <- pollenData[order(pollenData$age),]
lakeData <- lakeData[order(lakeData$age),]
charcoalData <- charcoalData[order(charcoalData$age),]
# index of the greatest charcoal age lass than the least pollen age
first.age.char <- max(which(charcoalData$age < min(pollenData$age)))
first.age.char
rm(list = ls())
graphics.off()
linterp <- function(x, y, x.out){
bad <- is.na(x) | is.na(y)
X <- x[!bad]
Y <- y[!bad]
Y <- Y[order(X)]
X <- X[order(X)]
a <- coef(lm(Y ~ X))[2] # slope
data.length <- length(X)
X.min <- X[1]
X.max <- X[data.length]
Y.min <- Y[1]
Y.max <- Y[data.length] # which.max takes the first instance, so we have to reverse
n.out <- length(x.out)
y.out <- numeric(n.out)
for(i in 1:n.out){
x0 <- x.out[i]
if(x0 < X.min){
y.out[i] <- a * (x0 - X.min) + Y.min
}else if(x0 > X.max){
y.out[i] <- a * (x0 - X.max) + Y.max
}else if(any(X == x0)){
y.out[i] <- mean(Y[which(X == x0)])
}else{
j <- max(which(X < x0))
y.out[i] <- (Y[j + 1] - Y[j]) / (X[j + 1] - X[j]) * (x0 - X[j]) + Y[j]
}
}
return(y.out)
}
pollenData <- read.csv("./data/20200722_pollen.csv")
lakeData <- read.csv("./data/20200722_lake.csv")
charcoalData <- read.csv("./data/20200722_charcoal.csv")
colnames(pollenData)[1] <- "age"
colnames(lakeData) <- c("age", "lake")
colnames(charcoalData) <- c("age", "charcoal")
# make sure data are in chronological order
pollenData <- pollenData[order(pollenData$age),]
lakeData <- lakeData[order(lakeData$age),]
charcoalData <- charcoalData[order(charcoalData$age),]
# index of the greatest charcoal age lass than the least pollen age
first.age.char <- max(which(charcoalData$age < min(pollenData$age)))
first.age.char
charcoalData$age
min(pollenData$age)
# index of the greatest charcoal age lass than the least pollen age
first.age.char <- max(which(charcoalData$age < min(pollenData$age)))
# index of the smallest charcoal age greater than the greatest pollen age
last.age.char <- min(which(charcoalData$age > max(pollenData$age)))
# truncate the charcoal data to just what is needed
char.trunc <- charcoalData[first.age.char:last.age.char,]
char.trunc
# interpolate linearly
char.linterp.pred <- linterp(x = char.trunc$age,
y = char.trunc$charcoal,
x.out = pollenData$age)
plot(char.trunc, type = "l", lwd = 2, main = "Charcoal Linear Interpolation")
points((pollenData$age - pollenData$age) ~ pollenData$age)
lines(char.linterp.pred ~ pollenData$age, lwd = 1, col = "red")
# index of the smallest charcoal age greater than the greatest pollen age
last.age.char <- min(which(charcoalData$age > max(pollenData$age)))
# truncate the charcoal data to just what is needed
char.trunc <- charcoalData[1:last.age.char,]
# interpolate linearly
char.linterp.pred <- linterp(x = char.trunc$age,
y = char.trunc$charcoal,
x.out = pollenData$age)
plot(char.trunc, type = "l", lwd = 2, main = "Charcoal Linear Interpolation")
lines(char.linterp.pred ~ pollenData$age, lwd = 1, col = "red")
# index of the smallest lake level age greater than the greatest pollen age
last.age.lake <- min(which(lakeData$age > max(pollenData$age)))
# truncate the lake level data to just what is needed
lake.trunc <- lakeData[1:last.age.lake,]
# interpolate linearly
lake.linterp.pred <- linterp(x = lake.trunc$age,
y = lake.trunc$lake,
x.out = pollenData$age)
plot(lake.trunc, type = "l", lwd = 2, main = "Charcoal Linear Interpolation")
lines(lake.linterp.pred ~ pollenData$age, lwd = 1, col = "red")
charcoalData.linterp <- data.frame("age" = pollenData$age,
"charcoal" = char.linterp.pred)
write.table(x = charcoalData.linterp,
file = "./data/20200722_char_linterp.csv",
row.names = F,
col.names = T,
sep = ",")
lakeData.linterp <- data.frame("age" = pollenData$age,
"lake" = lake.linterp.pred)
write.table(x = lakeData.linterp,
file = "./data/20200722_lake_linterp.csv",
row.names = F,
col.names = T,
sep = ",")
rm(list = ls())
graphics.off()
library(vegan)
library(MASS)
library(svglite)
# load the pollen data
poln.full <- read.csv("./data/20200626_pollen.csv")
# load the pollen data
poln.full <- read.csv("./data/20200722_pollen.csv")
# load interpolated data generated by code from Malawi_interpolation.R
# choose which interpolation method to use:
## linearly interpolated data:
lake.full <- read.csv("./data/20200722_lake_linterp.csv")
char.full <- read.csv("./data/20200722_char_linterp.csv")
# split the loaded data to mix and match as needed
age <- lake.full[,"age"] # everything should have the same ages
char <- char.full[,"charcoal"]
lake <- -1 * lake.full[,"lake"]
poln <- poln.full[,c("Poaceae", "Podocarpus", "miombo", "olea")]
poln
poln.full
poln <- poln.full[,c("Poaceae", "Podocarpus", "miombo", "Olea")]
# colnames(poln) <- c("Poaceae", "Podocarpus", "miombo", "Olea")
astr <- poln.full[,"asters"]
poln.full
# colnames(poln) <- c("Poaceae", "Podocarpus", "miombo", "Olea")
astr <- poln.full[,"Asteraceae"]
# a data.frame of data to be used in the vector fit
to.be.fit <- data.frame("age" = age,
"charcoal" = char,
"lake" = lake,
"asters" = astr)
# scale and center the datasets
poln.std <- vegan::decostand(x = poln,
method = "chi.square") # approximates chisquare distance
to.be.fit.std <- scale(x = to.be.fit)
# make distance matrices
poln.dist <- dist(poln.std)
# make the pollen ordination
poln.ord <- cmdscale(d = poln.dist, k = 4, eig = T, add = F, x.ret = F)
# get the proportion of the variation explained by each component
var.expl <- poln.ord$eig[1:3] / sum(poln.ord$eig[1:3])
poln.fit <- vegan::envfit(ord = poln.ord,
env = poln.std,
permutations = 10000)
add.fit <- vegan::envfit(ord = poln.ord,
env = to.be.fit.std,
permutations = 10000)
## color ages > 85 in red
col <- c("gray", "red")[1 + (age >= 85)]
main <- "PCoA of Pollen: pollen and independent vectors fitted onto ordination"
plot(poln.ord$points, pch = 21, type = "n",
xlab = paste0("PCoA I (", round(var.expl[1] * 100, 1), "%)"),
ylab = paste0("PCoA II (", round(var.expl[2] * 100, 1), "%)"), main = main,
col = "black", bg = col, cex = 1.5, xaxt = "n", yaxt = "n", bty = "n")
axis(1, at = seq(-0.5, 1, by = 0.25))
axis(2, at = seq(-1, 0.25, by = 0.25))
legend(0.5, -0.85,
pch = c(21, 21, NA),
lty = c(NA, NA, 1),
lwd = c(NA, NA, 2),
col = c("black", "black", "light blue"),
pt.bg =  c("gray","red", NA),
cex = 1.5,
legend = c("Post 85k", "Pre 85k", "Lake Level"))
#                 add = TRUE,
#                 col = "orange",
#                 nlevels = 50,
#                 knots = 300)
# vegan::ordisurf(x = poln.ord,
#                 y = char,
#                 main = "Charcoal",
#                 add = TRUE,
#                 col = "gray",
#                 nlevels = 50)
lake.surf <- vegan::ordisurf(x = poln.ord, y = lake,
main = "Lake Level",
plot = FALSE,
col = "orange",
nlevels = 50)
plot(lake.surf, add = T, col = "light blue", nlevels = 50, knots = 30)
# points(poln.ord$points, pch = 21,
#        xlab = paste0("PCoA I (", round(var.expl[1] * 100, 1), "%)"),
#        ylab = paste0("PCoA II (", round(var.expl[2] * 100,1), "%)"),
#        col = "black", bg = col, cex = 1.5, xaxt = "n", yaxt = "n", bty = "n")
plot(poln.fit, col = "dark green", add = T, lwd = 3)
plot(add.fit, col = "orange", add = T)
text(poln.ord$points, labels = round(age), cex = 0.5, col = col)
# our raw data are the pollen counts' PCoA scores and lake level
# EOC: we use the n-1 column of scores of the PCoA, because the nth eigenvalue is 0, and the scores are redundant
data.raw <- data.frame(poln.ord$points[,1:3], lake)
# scale the raw data
data.scl <- scale(data.raw)
# binary indicator of age
age.gt.85 <- 0 + (age > 85)
# perform the MANOVA
poln.manova <- vegan::adonis(formula = data.raw ~ age.gt.85,
method = "euclidean",
permutations = 10000)
poln.manova
## Title and axes
svglite::svglite(file = "./pictures/vector_graphics/axes.svg")
main <- "PCoA of Pollen: pollen and independent vectors fitted onto ordination"
plot(poln.ord$points, pch = 21, type = "n",
xlab = paste0("PCoA I (", round(var.expl[1] * 100, 1), "%)"),
ylab = paste0("PCoA II (", round(var.expl[2] * 100, 1), "%)"), main = main,
col = "black", bg = col, cex = 1.5, xaxt = "n", yaxt = "n", bty = "n")
axis(1, at = seq(-0.5, 1, by = 0.25))
axis(2, at = seq(-1, 0.25, by = 0.25))
dev.off()
## Legend
svglite::svglite(file = "./pictures/vector_graphics/legend.svg")
plot(x = 0, y = 0, type = "n",
xlab = NA, ylab = NA,
xlim = c(-1,1), ylim = c(-1,1),
axes = F)
legend(-1, 1,
pch = c(21, 21, NA),
lty = c(NA, NA, 1),
lwd = c(NA, NA, 2),
col = c("black", "black", "light blue"),
pt.bg =  c("gray","red", NA),
cex = 1.5,
legend = c("Post 85k", "Pre 85k", "Lake Level"))
dev.off()
## Ordination surface
svglite::svglite(file = "./pictures/vector_graphics/ordination_surface.svg")
plot(poln.ord$points, type = "n",
xlab = NA, ylab = NA,
axes = F)
lake.surf <- vegan::ordisurf(x = poln.ord, y = lake,
main = "Lake Level",
plot = FALSE,
col = "light blue",
nlevels = 50)
plot(lake.surf, add = T, col = "light blue", nlevels = 50, knots = 30)
dev.off()
## Pollen vector fit
### with labels
svglite::svglite(file = "./pictures/vector_graphics/pollen_vec_fit.svg")
plot(poln.ord$points, type = "n",
xlab = NA, ylab = NA,
axes = F)
plot(poln.fit, col = "dark green", add = T, lwd = 3)
dev.off()
### without labels
svglite::svglite(file = "./pictures/vector_graphics/pollen_vec_fit_noLabels.svg")
plot(poln.ord$points, type = "n",
xlab = NA, ylab = NA,
axes = F)
plot(poln.fit, col = "dark green", add = T, lwd = 3, labels = NA)
dev.off()
## Additional variable vector fits
### with labels
svglite::svglite(file = "./pictures/vector_graphics/additional_vec_fit.svg")
plot(poln.ord$points, type = "n",
xlab = NA, ylab = NA,
axes = F)
plot(add.fit, col = "orange", add = T)
dev.off()
### without labels
svglite::svglite(file = "./pictures/vector_graphics/additional_vec_fit_noLabels.svg")
plot(poln.ord$points, type = "n",
xlab = NA, ylab = NA,
axes = F)
plot(add.fit, col = "orange", add = T, labels = NA)
dev.off()
## Data points
### as ages
svglite::svglite(file = "./pictures/vector_graphics/data_pts_asAges.svg")
plot(poln.ord$points, type = "n",
xlab = NA, ylab = NA,
axes = F)
text(poln.ord$points, labels = round(age), cex = 0.5, col = col)
dev.off()
### as dots 1
svglite::svglite(file = "./pictures/vector_graphics/data_pts_asDots1.svg")
plot(poln.ord$points, type = "n",
xlab = NA, ylab = NA,
axes = F)
points(poln.ord$points, pch = 21, cex = 0.5, col = "black", bg = col)
dev.off()
### as dots 2
svglite::svglite(file = "./pictures/vector_graphics/data_pts_asDots2.svg")
plot(poln.ord$points, type = "n",
xlab = NA, ylab = NA,
axes = F)
points(poln.ord$points, pch = 19, cex = 0.5, col = col)
dev.off()
rm(list = ls())
graphics.off()
library(vegan)
library(MASS)
library(svglite)
# load the pollen data
poln.full <- read.csv("./data/20200722_pollen.csv")
# load interpolated data generated by code from Malawi_interpolation.R
# choose which interpolation method to use:
## linearly interpolated data:
lake.full <- read.csv("./data/20200722_lake_linterp.csv")
char.full <- read.csv("./data/20200722_char_linterp.csv")
## Krig interpolated data:
# lake.full <- read.csv("./data/lake_Krig.csv")
# char.full <- read.csv("./data/char_Krig.csv")
# split the loaded data to mix and match as needed
age <- lake.full[,"age"] # everything should have the same ages
char <- char.full[,"charcoal"]
lake <- -1 * lake.full[,"lake"]
poln <- poln.full[,c("Poaceae", "Podocarpus", "miombo", "Olea")]
# colnames(poln) <- c("Poaceae", "Podocarpus", "miombo", "Olea")
astr <- poln.full[,"Asteraceae"]
# a data.frame of data to be used in the vector fit
to.be.fit <- data.frame("age" = age,
"charcoal" = char,
"lake" = lake,
"asters" = astr)
# scale and center the datasets
poln.std <- vegan::decostand(x = poln,
method = "chi.square") # approximates chisquare distance
to.be.fit.std <- scale(x = to.be.fit)
# make distance matrices
poln.dist <- dist(poln.std)
# poln.dist <- vegan::vegdist(poln, method = "canberra")
# make the pollen ordination
poln.ord <- cmdscale(d = poln.dist, k = 4, eig = T, add = F, x.ret = F)
write.table(x = poln.ord$points, file = "./data/pollen_ordination.csv", row.names = F)
write.table(x = data.frame(poln.ord$points), file = "./data/pollen_ordination.csv", row.names = F)
?write.table
write.table(x = data.frame(poln.ord$points),
file = "./data/pollen_ordination.csv",
row.names = F,
sep = ",")
# make the pollen ordination
poln.ord <- cmdscale(d = poln.dist, k = 2, eig = T, add = F, x.ret = F)
# get the proportion of the variation explained by each component
var.expl <- poln.ord$eig[1:3] / sum(poln.ord$eig[1:3])
var.expl
poln.ord$points
# get the proportion of the variation explained by each component
var.expl <- poln.ord$eig[1:3] / sum(poln.ord$eig[1:3])
poln.fit <- vegan::envfit(ord = poln.ord,
env = poln.std,
permutations = 10000)
add.fit <- vegan::envfit(ord = poln.ord,
env = to.be.fit.std,
permutations = 10000)
## color ages > 85 in red
col <- c("gray", "red")[1 + (age >= 85)]
main <- "PCoA of Pollen: pollen and independent vectors fitted onto ordination"
plot(poln.ord$points, pch = 21, type = "n",
xlab = paste0("PCoA I (", round(var.expl[1] * 100, 1), "%)"),
ylab = paste0("PCoA II (", round(var.expl[2] * 100, 1), "%)"), main = main,
col = "black", bg = col, cex = 1.5, xaxt = "n", yaxt = "n", bty = "n")
axis(1, at = seq(-0.5, 1, by = 0.25))
axis(2, at = seq(-1, 0.25, by = 0.25))
legend(0.5, -0.85,
pch = c(21, 21, NA),
lty = c(NA, NA, 1),
lwd = c(NA, NA, 2),
col = c("black", "black", "light blue"),
pt.bg =  c("gray","red", NA),
cex = 1.5,
legend = c("Post 85k", "Pre 85k", "Lake Level"))
#                 add = TRUE,
#                 col = "orange",
#                 nlevels = 50,
#                 knots = 300)
# vegan::ordisurf(x = poln.ord,
#                 y = char,
#                 main = "Charcoal",
#                 add = TRUE,
#                 col = "gray",
#                 nlevels = 50)
lake.surf <- vegan::ordisurf(x = poln.ord, y = lake,
main = "Lake Level",
plot = FALSE,
col = "orange",
nlevels = 50)
plot(lake.surf, add = T, col = "light blue", nlevels = 50, knots = 30)
# points(poln.ord$points, pch = 21,
#        xlab = paste0("PCoA I (", round(var.expl[1] * 100, 1), "%)"),
#        ylab = paste0("PCoA II (", round(var.expl[2] * 100,1), "%)"),
#        col = "black", bg = col, cex = 1.5, xaxt = "n", yaxt = "n", bty = "n")
plot(poln.fit, col = "dark green", add = T, lwd = 3)
plot(add.fit, col = "orange", add = T)
text(poln.ord$points, labels = round(age), cex = 0.5, col = col)
# our raw data are the pollen counts' PCoA scores and lake level
# EOC: we use the n-1 column of scores of the PCoA, because the nth eigenvalue is 0, and the scores are redundant
data.raw <- data.frame(poln.ord$points[,1:3], lake)
# make the pollen ordination
poln.ord <- cmdscale(d = poln.dist, k = 4, eig = T, add = F, x.ret = F)
write.table(x = data.frame(poln.ord$points),
file = "./data/pollen_ordination.csv",
row.names = F,
sep = ",")
# make the pollen ordination
poln.ord <- cmdscale(d = poln.dist, k = 4, eig = T, add = F, x.ret = F)
write.table(x = data.frame(poln.ord$points),
file = "./data/pollen_ordination.csv",
row.names = F,
sep = ",")
data.frame("r" = poln.ord$points)
write.table(x = data.frame("PCoA_Component" = poln.ord$points),
file = "./data/pollen_ordination.csv",
row.names = F,
sep = ",")
var.expl
poln.ord$eig
data.frame(poln.std, "PCoA_Component" = poln.ord$points)
write.table(x = data.frame(poln.std, "PCoA_Component" = poln.ord$points),
file = "./data/pollen_ordination.csv",
row.names = F,
sep = ",")
poln
poln.full
data.frame(poln.full$Pollen.Age,
poln.std,
"PCoA_Component" = poln.ord$points)
data.frame("age" = poln.full$Pollen.Age,
poln.std,
"PCoA_Component" = poln.ord$points)
write.table(x = data.frame("age" = poln.full$Pollen.Age,
poln.std,
"PCoA_Component" = poln.ord$points),
file = "./data/pollen_ordination.csv",
row.names = F,
sep = ",")
rm(list = ls())
graphics.off()
library(vegan)
library(MASS)
library(svglite)
# load the pollen data
poln.full <- read.csv("./data/20200722_pollen.csv")
# load interpolated data generated by code from Malawi_interpolation.R
# choose which interpolation method to use:
## linearly interpolated data:
lake.full <- read.csv("./data/20200722_lake_linterp.csv")
char.full <- read.csv("./data/20200722_char_linterp.csv")
## Krig interpolated data:
# lake.full <- read.csv("./data/lake_Krig.csv")
# char.full <- read.csv("./data/char_Krig.csv")
# split the loaded data to mix and match as needed
age <- lake.full[,"age"] # everything should have the same ages
char <- char.full[,"charcoal"]
lake <- -1 * lake.full[,"lake"]
poln <- poln.full[,c("Poaceae", "Podocarpus", "miombo", "Olea")]
# colnames(poln) <- c("Poaceae", "Podocarpus", "miombo", "Olea")
astr <- poln.full[,"Asteraceae"]
# a data.frame of data to be used in the vector fit
to.be.fit <- data.frame("age" = age,
"charcoal" = char,
"lake" = lake,
"asters" = astr)
# scale and center the datasets
poln.std <- vegan::decostand(x = poln,
method = "chi.square") # approximates chisquare distance
to.be.fit.std <- scale(x = to.be.fit)
# make distance matrices
poln.dist <- dist(poln.std)
# poln.dist <- vegan::vegdist(poln, method = "canberra")
# make the pollen ordination
poln.ord <- cmdscale(d = poln.dist, k = 4, eig = T, add = F, x.ret = F)
write.table(x = data.frame("age" = poln.full$Pollen.Age,
poln,
"PCoA_Component" = poln.ord$points),
file = "./data/pollen_ordination.csv",
row.names = F,
sep = ",")
