<td valign='top'>
<p>
<img
width='140'
height='140'
src='file:///E:/Dropbox (LCA)/Documents/Purdue/Courses/code/eocpic.png'
alt='cid:image001.png@01D27AE4.ECAF4F90'
/>
</p>
</td>
<td width='500' valign='top'>
<p>
<strong>Erik Otarola-Castillo, PhD</strong>
</p>
<p>
<strong></strong>
</p>
<p>
<strong>Assistant Professor </strong>
|<strong> </strong>Purdue University | Department of Anthropology</p>
700 West State Street, Suite 219, West Lafayette, IN 47907-2059
</p>
<p>
p: 765-494-2443 f: 765-496-7411 m: 631-796-7331
</p>
<p>
w:
<a href='http://www.eotarola.com/' target='_blank'>
www.eotarola.com
</a>
e:
<a href='mailto:eoc@purdue.edu' target='_blank'>
eoc@purdue.edu
</a>
skype: erik.otarola-castillo
</p>
<p>
<a
href='https://www.facebook.com/groups/quantarch/'
target='_blank'
>
<img
border='0'
width='25'
height='25'
src='file:///E:/Dropbox (LCA)/Documents/Purdue/Courses/code/FBpic1.png'
alt='cid:image003.png@01D27A46.909F8B00'
/>
</a>
<a href='https://twitter.com/Dr_EOC' target='_blank'>
<img
border='0'
width='25'
height='25'
src='file:///E:/Dropbox (LCA)/Documents/Purdue/Courses/code/twitpic1.png'
alt='cid:image004.png@01D27A46.909F8B00'
/>
</a>
</p>
</td>
</tr>
</tbody>
</table>
", sep="")
lst<-list.files(full.names = TRUE,path = "C:\\Users\\eotarola.BOILERAD\\Box\\Box_LCA\\Students\\Sarah Coon\\201_2020\\Marketing\\flyers\\", pattern=".pdf")
for (i in 1:length(lst)){
Email[["Attachments"]]$Add(lst[i])
}
# Send the message
Email$Send()
# Close Outlook, clear the message
rm(Outlook, Email)
}
for (i in 4:length(dat$First)){
cat(i, "\n")
name<-dat$First[i]
# Open Outlook
Outlook <- COMCreate("Outlook.Application")
# Create a new message
Email = Outlook$CreateItem(0)
# Set the recipient, subject, and body
Email[["to"]] = as.character(dat$Email[i]) #"eoc@purdue.edu"#
Email[["cc"]] = ""
Email[["bcc"]] = ""
Email[["subject"]] = "Introduction to Archaeology, fall 2020"
Email[["htmlbody"]] =
paste("<p>Dear ", name,",</p>
<p>Greetings from the <b> Department of Anthropology</b>. I trust all is well in ",as.character(dat$College[i]), " advising.","
<p>I just wanted to remind you that I am teaching a course this fall 2020 which might interest your incoming students and those who are still be looking around to add a class. This course fulfills several university wide program requirements including University and College Cores, and the new Cornerstone Certificate. </p>
<p>The course is, </p>
<p><b>ANTH 201 INTRODUCTION TO ARCHAEOLOGY AND WORLD PREHISTORY</b>. Using in-class demonstrations, the course is a fun introduction to archaeology and human prehistory from the earliest <i>Homo sapiens</i> to the development of agriculture and states. The course is perfect for any student interested in adding a course outside of their major. I teach this course using a fun and interactive format where students observe demonstrations of ancient technologies and in-class experiments (no labs) to experience archaeological science first hand.</p>
<p> This is a hybrid course, available as a traditional IN PERSON (CRN 22787) and ONLINE (CRN 26715) format. </p>
<p>This is an updated <b>2-minute video compilation of in-class demonstrations</b>: https://bit.ly/2WGlCF2 </p>
<p>Thanks for passing the word! I hope your students find this useful.</p>
<p>Erik</p>
<p> </p>
<table border='0' cellspacing='5' cellpadding='5'>
<tbody>
<tr>
<td valign='top'>
<p>
<img
width='140'
height='140'
src='file:///E:/Dropbox (LCA)/Documents/Purdue/Courses/code/eocpic.png'
alt='cid:image001.png@01D27AE4.ECAF4F90'
/>
</p>
</td>
<td width='500' valign='top'>
<p>
<strong>Erik Otarola-Castillo, PhD</strong>
</p>
<p>
<strong></strong>
</p>
<p>
<strong>Assistant Professor </strong>
|<strong> </strong>Purdue University | Department of Anthropology</p>
700 West State Street, Suite 219, West Lafayette, IN 47907-2059
</p>
<p>
p: 765-494-2443 f: 765-496-7411 m: 631-796-7331
</p>
<p>
w:
<a href='http://www.eotarola.com/' target='_blank'>
www.eotarola.com
</a>
e:
<a href='mailto:eoc@purdue.edu' target='_blank'>
eoc@purdue.edu
</a>
skype: erik.otarola-castillo
</p>
<p>
<a
href='https://www.facebook.com/groups/quantarch/'
target='_blank'
>
<img
border='0'
width='25'
height='25'
src='file:///E:/Dropbox (LCA)/Documents/Purdue/Courses/code/FBpic1.png'
alt='cid:image003.png@01D27A46.909F8B00'
/>
</a>
<a href='https://twitter.com/Dr_EOC' target='_blank'>
<img
border='0'
width='25'
height='25'
src='file:///E:/Dropbox (LCA)/Documents/Purdue/Courses/code/twitpic1.png'
alt='cid:image004.png@01D27A46.909F8B00'
/>
</a>
</p>
</td>
</tr>
</tbody>
</table>
", sep="")
lst<-list.files(full.names = TRUE,path = "C:\\Users\\eotarola.BOILERAD\\Box\\Box_LCA\\Students\\Sarah Coon\\201_2020\\Marketing\\flyers\\", pattern=".pdf")
for (i in 1:length(lst)){
Email[["Attachments"]]$Add(lst[i])
}
# Send the message
Email$Send()
# Close Outlook, clear the message
rm(Outlook, Email)
}
=======
##########################################
# MANOVA
# our raw data are the pollen counts' PCoA scores and lake level
# EOC: we use the n-1 column of scores of the PCoA, because the nth eigenvalue is 0, and the scores are redundant
data.raw <- data.frame(poln.ord$points[,1:3], lake)
# scale the raw data
data.scl <- scale(data.raw)
# EOC: the data in data.raw should already be euclidean, so the rest of this is superfluous
# # calculate the euclidean distance matrix of our scaled data
# data.scl.dist <- dist(data.scl)
#
# # perform our PCoA on the distance matrix and keep the eigenvalues
# data.scl.dist.pcoa <- cmdscale(d = data.scl.dist, k = 3, eig = T)
# data.scl.dist.pcoa.eig <- data.scl.dist.pcoa$eig
#
# # find the euclidean distance matrix of the resulting points
# data.scl.dist.pcoa.dist <- vegan::vegdist(x = data.scl.dist.pcoa$points,
#                                           method = "euclidean")
# binary indicator of age
age.gt.85 <- 0 + (age > 85)
# perform the MANOVA
poln.manova <- vegan::adonis(formula = data.raw ~ age.gt.85,
method = "euclidean",
permutations = 10000)
poln.manova
>>>>>>> b041c226605a92d5bb430301a919407244608d46
rm(list = ls())
graphics.off()
library(vegan)
library(MASS)
library(svglite)
# load the pollen data
poln.full <- read.csv("./data/20200626_pollen.csv")
# load interpolated data generated by code from Malawi_interpolation.R
# choose which interpolation method to use:
## linearly interpolated data:
lake.full <- read.csv("./data/lake_linterp.csv")
char.full <- read.csv("./data/char_linterp.csv")
<<<<<<< HEAD
=======
## Krig interpolated data:
# lake.full <- read.csv("./data/lake_Krig.csv")
# char.full <- read.csv("./data/char_Krig.csv")
>>>>>>> b041c226605a92d5bb430301a919407244608d46
# split the loaded data to mix and match as needed
age <- lake.full[,"age"] # everything should have the same ages
char <- char.full[,"charcoal"]
lake <- -1 * lake.full[,"lake"]
poln <- poln.full[,c("Poaceae", "Podocarpus", "miombo", "olea")]
colnames(poln) <- c("Poaceae", "Podocarpus", "miombo", "Olea")
astr <- poln.full[,"asters"]
# a data.frame of data to be used in the vector fit
to.be.fit <- data.frame("age" = age,
"charcoal" = char,
"lake" = lake,
"asters" = astr)
# scale and center the datasets
poln.std <- vegan::decostand(x = poln,
method = "chi.square") # approximates chisquare distance
to.be.fit.std <- scale(x = to.be.fit)
# make distance matrices
poln.dist <- dist(poln.std)
# make the pollen ordination
poln.ord <- cmdscale(d = poln.dist, k = 4, eig = T, add = F, x.ret = F)
# get the proportion of the variation explained by each component
var.expl <- poln.ord$eig[1:3] / sum(poln.ord$eig[1:3])
<<<<<<< HEAD
=======
##########################################
#	NMDS
# poln.ord <- vegan::metaMDS(comm = poln.ord$points,
#                            k = 2,
#                            distance = 'euclidean',
#                            autotransform = F)
# poln.ord <- MASS::isoMDS(d = poln.dist,
#                          y = cmdscale(d = poln.dist,
#                                       k = 2,
#                                       eig = T,
#                                       add = F,
#                                       x.ret = F)$points,
#                          k = 2,
#                          maxit = 50,
#                          trace = TRUE,
#                          tol = 1e-3,
#                          p = 2)
# MASS::Shepard(d = poln.dist, y = poln.ord, p = 2)
##########################################
# do the vector fit(s) of the data to our ordination
>>>>>>> b041c226605a92d5bb430301a919407244608d46
poln.fit <- vegan::envfit(ord = poln.ord,
env = poln.std,
permutations = 10000)
add.fit <- vegan::envfit(ord = poln.ord,
env = to.be.fit.std,
permutations = 10000)
<<<<<<< HEAD
## color ages > 85 in red
col <- c("gray", "red")[1 + (age >= 85)]
main <- "PCoA of Pollen: pollen and independent vectors fitted onto ordination"
plot(poln.ord$points, pch = 21, type = "p",
=======
##########################################
# plot the results of the vector fits
## color ages > 85 in red
col <- c("gray", "red")[1 + (age >= 85)]
main <- "PCoA of Pollen: pollen and independent vectors fitted onto ordination"
plot(poln.ord$points, pch = 21, type = "n",
>>>>>>> b041c226605a92d5bb430301a919407244608d46
xlab = paste0("PCoA I (", round(var.expl[1] * 100, 1), "%)"),
ylab = paste0("PCoA II (", round(var.expl[2] * 100, 1), "%)"), main = main,
col = "black", bg = col, cex = 1.5, xaxt = "n", yaxt = "n", bty = "n")
axis(1, at = seq(-0.5, 1, by = 0.25))
axis(2, at = seq(-1, 0.25, by = 0.25))
legend(0.5, -0.85,
pch = c(21, 21, NA),
lty = c(NA, NA, 1),
lwd = c(NA, NA, 2),
col = c("black", "black", "light blue"),
pt.bg =  c("gray","red", NA),
<<<<<<< HEAD
cex = 1.25,
legend = c("Post 85k", "Pre 85k", "Lake Level"))
=======
cex = 1.5,
legend = c("Post 85k", "Pre 85k", "Lake Level"))
## ordination surfaces
# vegan::ordisurf(x = poln.ord,
#                 y = age,
#                 main = "Age (kyr)",
>>>>>>> b041c226605a92d5bb430301a919407244608d46
#                 add = TRUE,
#                 col = "orange",
#                 nlevels = 50,
#                 knots = 300)
# vegan::ordisurf(x = poln.ord,
#                 y = char,
#                 main = "Charcoal",
#                 add = TRUE,
#                 col = "gray",
#                 nlevels = 50)
lake.surf <- vegan::ordisurf(x = poln.ord, y = lake,
<<<<<<< HEAD
main = "Lake Level",
plot = FALSE,
col = "orange",
nlevels = 50)
plot(lake.surf, add = T, col = "light blue", nlevels = 50, knots = 30)
# points(poln.ord$points, pch = 21,
#        xlab = paste0("PCoA I (", round(var.expl[1] * 100, 1), "%)"),
#        ylab = paste0("PCoA II (", round(var.expl[2] * 100,1), "%)"),
#        col = "black", bg = col, cex = 1.5, xaxt = "n", yaxt = "n", bty = "n")
plot(poln.fit, col = "dark green", add = T, lwd = 3)
plot(add.fit, col = "orange", add = T)
text(poln.ord$points, labels = round(age), cex = 0.5, col = col)
=======
main = "Lake Level",
plot = FALSE,
col = "orange",
nlevels = 50)
plot(lake.surf, add = T, col = "light blue", nlevels = 50, knots = 30)
# vegan::ordisurf(x = poln.ord,
#                 y = astr,
#                 main = "Asteraceae")
# points(poln.ord$points, pch = 21,
#        xlab = paste0("PCoA I (", round(var.expl[1] * 100, 1), "%)"),
#        ylab = paste0("PCoA II (", round(var.expl[2] * 100,1), "%)"),
#        col = "black", bg = col, cex = 1.5, xaxt = "n", yaxt = "n", bty = "n")
plot(poln.fit, col = "dark green", add = T, lwd = 3)
plot(add.fit, col = "orange", add = T)
text(poln.ord$points, labels = round(age), cex = 0.5, col = col)
##########################################
# MANOVA
# our raw data are the pollen counts' PCoA scores and lake level
# EOC: we use the n-1 column of scores of the PCoA, because the nth eigenvalue is 0, and the scores are redundant
data.raw <- data.frame(poln.ord$points[,1:3], lake)
# scale the raw data
data.scl <- scale(data.raw)
# EOC: the data in data.raw should already be euclidean, so the rest of this is superfluous
# # calculate the euclidean distance matrix of our scaled data
# data.scl.dist <- dist(data.scl)
#
# # perform our PCoA on the distance matrix and keep the eigenvalues
# data.scl.dist.pcoa <- cmdscale(d = data.scl.dist, k = 3, eig = T)
# data.scl.dist.pcoa.eig <- data.scl.dist.pcoa$eig
#
# # find the euclidean distance matrix of the resulting points
# data.scl.dist.pcoa.dist <- vegan::vegdist(x = data.scl.dist.pcoa$points,
#                                           method = "euclidean")
# binary indicator of age
age.gt.85 <- 0 + (age > 85)
# perform the MANOVA
poln.manova <- vegan::adonis(formula = data.raw ~ age.gt.85,
method = "euclidean",
permutations = 10000)
poln.manova
####################################
#### plot components separately ####
####################################
## Title and axes
svglite::svglite(file = "./pictures/vector_graphics/axes.svg")
main <- "PCoA of Pollen: pollen and independent vectors fitted onto ordination"
plot(poln.ord$points, pch = 21, type = "n",
xlab = paste0("PCoA I (", round(var.expl[1] * 100, 1), "%)"),
ylab = paste0("PCoA II (", round(var.expl[2] * 100, 1), "%)"), main = main,
col = "black", bg = col, cex = 1.5, xaxt = "n", yaxt = "n", bty = "n")
axis(1, at = seq(-0.5, 1, by = 0.25))
axis(2, at = seq(-1, 0.25, by = 0.25))
dev.off()
## Legend
svglite::svglite(file = "./pictures/vector_graphics/legend.svg")
plot(x = 0, y = 0, type = "n",
xlab = NA, ylab = NA,
xlim = c(-1,1), ylim = c(-1,1),
axes = F)
legend(-1, 1,
pch = c(21, 21, NA),
lty = c(NA, NA, 1),
lwd = c(NA, NA, 2),
col = c("black", "black", "light blue"),
pt.bg =  c("gray","red", NA),
cex = 1.5,
legend = c("Post 85k", "Pre 85k", "Lake Level"))
dev.off()
## Ordination surface
svglite::svglite(file = "./pictures/vector_graphics/ordination_surface.svg")
plot(poln.ord$points, type = "n",
xlab = NA, ylab = NA,
axes = F)
lake.surf <- vegan::ordisurf(x = poln.ord, y = lake,
main = "Lake Level",
plot = FALSE,
col = "light blue",
nlevels = 50)
plot(lake.surf, add = T, col = "light blue", nlevels = 50, knots = 30)
dev.off()
## Pollen vector fit
### with labels
svglite::svglite(file = "./pictures/vector_graphics/pollen_vec_fit.svg")
plot(poln.ord$points, type = "n",
xlab = NA, ylab = NA,
axes = F)
plot(poln.fit, col = "dark green", add = T, lwd = 3)
dev.off()
### without labels
svglite::svglite(file = "./pictures/vector_graphics/pollen_vec_fit_noLabels.svg")
plot(poln.ord$points, type = "n",
xlab = NA, ylab = NA,
axes = F)
plot(poln.fit, col = "dark green", add = T, lwd = 3, labels = NA)
dev.off()
## Additional variable vector fits
### with labels
svglite::svglite(file = "./pictures/vector_graphics/additional_vec_fit.svg")
plot(poln.ord$points, type = "n",
xlab = NA, ylab = NA,
axes = F)
plot(add.fit, col = "orange", add = T)
dev.off()
### without labels
svglite::svglite(file = "./pictures/vector_graphics/additional_vec_fit_noLabels.svg")
plot(poln.ord$points, type = "n",
xlab = NA, ylab = NA,
axes = F)
plot(add.fit, col = "orange", add = T, labels = NA)
dev.off()
## Data points
### as ages
svglite::svglite(file = "./pictures/vector_graphics/data_pts_asAges.svg")
plot(poln.ord$points, type = "n",
xlab = NA, ylab = NA,
axes = F)
text(poln.ord$points, labels = round(age), cex = 0.5, col = col)
dev.off()
### as dots 1
svglite::svglite(file = "./pictures/vector_graphics/data_pts_asDots1.svg")
plot(poln.ord$points, type = "n",
xlab = NA, ylab = NA,
axes = F)
points(poln.ord$points, pch = 21, cex = 0.5, col = "black", bg = col)
dev.off()
### as dots 2
svglite::svglite(file = "./pictures/vector_graphics/data_pts_asDots2.svg")
plot(poln.ord$points, type = "n",
xlab = NA, ylab = NA,
axes = F)
points(poln.ord$points, pch = 19, cex = 0.5, col = col)
dev.off()
>>>>>>> b041c226605a92d5bb430301a919407244608d46
install.packages("openxlsx")
library(openxlsx)
core2a <- read.xlsx(xlsxFile = "./data/Core2A_MagSusCharcoal.xlsx")
core2a <- read.xlsx(xlsxFile = "./data/Core2A_MagSusCharcoal.xlsx")
core2a
core2a_Charcoal <- read.xlsx(xlsxFile = "./data/Core2A_MagSusCharcoal.xlsx", sheet = 1)
core2a_MagSus <- read.xlsx(xlsxFile = "./data/Core2A_MagSusCharcoal.xlsx", sheet = 2)
core2a_MagSus
linterp <- function(x, y, x.out){
bad <- is.na(x) | is.na(y)
X <- x[!bad]
Y <- y[!bad]
Y <- Y[order(X)]
X <- X[order(X)]
a <- coef(lm(Y ~ X))[2] # slope
data.length <- length(X)
X.min <- X[1]
X.max <- X[data.length]
Y.min <- Y[1]
Y.max <- Y[data.length] # which.max takes the first instance, so we have to reverse
n.out <- length(x.out)
y.out <- numeric(n.out)
for(i in 1:n.out){
x0 <- x.out[i]
if(x0 < X.min){
y.out[i] <- a * (x0 - X.min) + Y.min
}else if(x0 > X.max){
y.out[i] <- a * (x0 - X.max) + Y.max
}else if(any(X == x0)){
y.out[i] <- mean(Y[which(X == x0)])
}else{
j <- max(which(X < x0))
y.out[i] <- (Y[j + 1] - Y[j]) / (X[j + 1] - X[j]) * (x0 - X[j]) + Y[j]
}
}
return(y.out)
}
core2a_downsampled <- linterp(x = core2a_MagSus$Depth,
y = core2a_MagSus$MagSus,
x.out = core2a_Charcoal$Depth)
core2a_downsampled
core2a_downsampled <- cbind("Depth" = core2a_Charcoal$Depth,
"MS_downsampled" = linterp(x = core2a_MagSus$Depth,
y = core2a_MagSus$MagSus,
x.out = core2a_Charcoal$Depth))
core2a_downsampled
write.table(x = core2a_downsampled,
file = "./data/Core2A_MagSusDownsampled.csv",
row.names = F,
sep = ",")
<<<<<<< HEAD
